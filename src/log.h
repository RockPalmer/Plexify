/* This structure is meant to be a representation of any propositional logic expression that
 * might be generated by the <truth_table> class. 
 *
 * This struct has 5 data members: <gate>, <val>, <type>, <var_name>, and <args>
 * 
 * The <gate> data member defines the gate or logical operator that is defined for this
 * log if there is one. The valid gates that can be set for this field are defined in 
 * "truth_values.h". They are NONE, NOT, AND, NAND, OR, NOR, XOR, XNOR, MUX. In the case
 * where the expression contains no gate/operator, this field is set to NONE. Exampled of
 * creating logical expressions while with gates can be found below in examples 4 & 5.
 * 
 * The <val> data member defines the literal logical value of the expression if this expression
 * is either a tautology or a contradiction. The valid logical values for this field are defined 
 * in "truth_values.h" and they are shared with the "truth_table.h" class. They are HI, LO, and 
 * DC where HI represents a tautology, LO represents a contradiction, and DC is only used when
 * the expression is not defined by a single literal logical value. Examples of creating logical
 * expressions that are tautologies and contradictions can be found below in examples 1 & 2.
 * 
 * The <var_name> data member defines the name of the propositional variable that this 
 * expression represents if it represents a single propositional variable. Otherwise, this is set 
 * to an empty string. An example of creating a logical expression that consists of 1
 * propositional variable can be found below in example 3.
 * 
 * The <args> data member defines the arguments of the logical expression if it has any.
 * By default, this is an empty list. Examples of creating logical expression with arguments
 * can be found below in examples 4 & 5.
 * 
 * The <type> data member divides all logical expressions into 3 types: LITERAL, VARIABLE, and 
 * EXPRESSION. This field determines how the rest of the data members in the log are interpreted.
 * 
 * Below are examples on how to represent any boolean expression using the above parameters.
 * 
 * Example 1: The expression is a tautology
 * 		
 * 		Logical expression: 	true
 * 		Initialization:			log* log1 = new log(HI,LITERAL);
 * 		How the data is stored:
 * 
 * 			log1 = log {
 * 				char gate 			 	= NONE
 * 				char val 				= LO
 * 				log_type type 			= LITERAL
 * 				std::string var_name 	= ""
 * 				args 					= {}
 * 			}
 * 
 * Example 2: The expression is a contradiction
 * 
 * 		Logical expression: 	false
 * 		Initialization:			log* log1 = new log(LO,LITERAL);	
 * 		How the data is stored:
 * 
 * 			log1 = log {
 * 				char gate 			 	= NONE
 * 				char val 				= LO
 * 				log_type type 			= LITERAL
 * 				std::string var_name 	= ""
 * 				args 					= {}
 * 			}
 * 
 * Example 3: The expression is defined by a single propositional variable named "b".
 * 
 * 		Logical expression: 	b
 * 		Initialization:			log* log1 = new log("b");
 * 		How the data is stored:
 * 
 * 			log1 = log {
 * 				char gate 			 	= NONE
 * 				char val 				= DC
 * 				log_type type 			= VARIABLE
 * 				std::string var_name 	= "b"
 * 				args 					= {}
 * 			}
 * 
 * Example 4: The logical expression is defined as the negation of another logical expression
 * 		that is stored in the pointer <log2>.
 * 
 * 		Logical expression: 	not <log2>
 * 		Initialization:			log* log2 = // However <log2> was defined
 * 								log* log1 = new log(NOT,EXPRESSION);
 *								log1->args.append(log2);
 * 		How the data is stored:
 * 
 * 			log1 = log {
 * 				char gate = NOT;
 * 				char val = DC;
 * 				log_type type = EXPRESSION;
 * 				std::string var_name = "";
 * 				ptr_linked_list<log> args = {
 * 					log2 = log{
 *						// However <log2> was defined
 *					}
 * 				}
 * 			}
 * 
 * Example 5: The logical expression is defined as the logical conjunction of 2 other logical
 * 		expressions stored in <log2> and <log3>.
 * 
 * 		Logical expression: 	<log2> and <log3>
 * 		Initialization:			log* log2 = // However <log2> was defined
 * 								log* log3 = // However <log3> was defined
 * 								log* log1 = new log(AND,EXPRESSION);
 *								log1->args.append(log2);
 * 								log1->args.append(log3);
 * 		How the data is stored:
 * 
 * 			log1 = log {
 * 				char gate = AND;
 * 				char val = DC;
 * 				log_type type = EXPRESSION;
 * 				std::string var_name = "";
 * 				ptr_linked_list<log> args = {
 * 					log2 = log{
 *						// However <log2> was defined
 *					},
 * 					log3 = log{
 * 						// However <log3> was defined
 * 					}
 * 				}
 * 			}
 */

#ifndef _LOG_
#define _LOG_

#include "ptr_linked_list.h"
#include "truth_values.h"
#include <string>

struct log {

	char gate;
	char val;
	log_type type;
	std::string var_name;
	ptr_linked_list<log> args;

	log();
	log(char c, log_type t);
	log(std::string v);
	~log();

	std::string to_string();
	log* invert();
	bool equal_to(log* l);
	bool contains(log* l, bool*& elements, size_t& len);
	bool demorgify();
	bool polarity();
	void invert_this();
	void copy(log* l);
};

#endif
