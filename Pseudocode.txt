log ::= {type,name,value,args}
log.type ∈ {1,2,3}
log.value ∈ {HI,LO,DC}

REDUCE(charᴹˣᴺ cases):
	let state = 0

	while state < 4:
		let instance_found = false
		switch (state):
			case 0:
				foreach i ∈ [0,M) and not instance_found:
					foreach i ∈ [i + 1,M) and not instance_found:
						if cases[i] = cases[j]:
							remove cases[j]]
							instance_found = true
				if not instance_found:
					state = state  1
				break
			case 1:
				foreach i ∈ [0,M) and not instance_found:
					foreach i ∈ [i + 1,M) and not instance_found:
						if CONTAINS(cases[i],cases[j]):
							remove cases[j]
							instance_found = true
							state = 0
						else if CONTAINS(cases[j],cases[i]):
							remove cases[i]
							instance_found = true
							state = 0
				if not instance_found
					state = state + 1
				break
			case 2:
				foreach i ∈ [0,M) and not instance_found:
					foreach i ∈ [i + 1,M) and not instance_found:
						let index = EQUALS_EXCEPT(cases[i],cases[j])
						if index ≠ -1:
							cases[i][index] = DC
							remove cases[j]
							instance_found = true
							state = 0
				if not instance_found
					state = state + 1
				break
			case 3:
				foreach i ∈ [0,M) and not instance_found:
					foreach i ∈ [i + 1,M) and not instance_found:
						let index = CONTAINS_EXCEPT(cases[i],cases[j])
						if index ≠ -1:
							cases[i][index] = DC
							remove cases[j]
							instance_found = true
							state = 0
						else:
							index = CONTAINS_EXCEPT(cases[j],cases[i])
							if index ≠ -1:
								cases[j][index] = DC
								remove cases[i]
								instance_found = true
								state = 0
				if not instance_found
					state = state + 1
				break
	return cases